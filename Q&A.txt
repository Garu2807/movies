1) Как работает распространение событий (Event Propagation)

Если кликнуть по кнопке внутри блока, событие проходит путь:
- сначала сверху вниз (capture): window → document → html → body → ... → цель
- затем фаза цели (target)
- затем снизу вверх (bubble): цель → ... → body → html → document → window

По умолчанию обработчики работают на всплытии. Если указать
`addEventListener('click', handler, { capture: true })`, то он сработает
на этапе перехвата.

Как это применять:
- делегирование: один обработчик на родителе ловит клики по детям
- перехват на верхнем уровне: можно первым остановить событие
- stopPropagation/stopImmediatePropagation — остановка дальнейшего пути
- preventDefault — отмена стандартного действия (не влияет на фазы)


2) Promise и Event Loop

Promise — это объект, который представляет результат асинхронной операции.
Состояния:
- pending (ожидание)
- fulfilled (успех)
- rejected (ошибка)

Использование: `then` для результата, `catch` для ошибки, `finally` всегда.

Другой способ писать асинхронный код — `async/await` (удобный синтаксис над Promise).

Event Loop управляет очередями задач. Коллбеки промисов попадают в очередь
микрозадач и выполняются сразу после завершения текущего синхронного кода,
раньше, чем обычные таймеры и события (макрозадачи).


3) ООП и как оно реализовано в JavaScript

ООП — это способ строить программу из объектов.
Ключевые принципы:
- инкапсуляция: прячем внутренние детали и даем понятный интерфейс
- наследование: один класс расширяет другой
- полиморфизм: одинаковый интерфейс, но разное поведение
- абстракция: выделяем главное, скрываем лишнее

В JS основа — прототипы. `class` — синтаксический сахар над ними.
Пример:

class User {
  constructor(name) { this.name = name; }
  sayHi() { return `Hi, ${this.name}`; }
}

class Admin extends User {
  ban() { /* ... */ }
}

Методы лежат в `User.prototype`. Наследование идет через цепочку прототипов.
Для инкапсуляции есть приватные поля `#secret`, замыкания и модульная
организация кода.


4) Как браузер обрабатывает URL

1. Вы ввели адрес → браузер парсит URL
2. Проверяет кеш, HSTS, возможные preconnect/prefetch
3. DNS‑запрос: домен → IP (с кешами)
4. Соединение: TCP, а для HTTPS еще TLS‑рукопожатие
5. Отправка HTTP‑запроса → ответ от сервера
6. Парсинг HTML → строится DOM
7. Загружается CSS/JS/картинки → строится CSSOM
8. DOM + CSSOM → render tree → layout → paint

Что ускоряет:
- HTTP/2 или HTTP/3
- кэширование (Cache-Control, ETag)
- CDN
- preconnect/preload/prefetch
- сжатие (gzip/brotli)
- lazy loading

Проблемы и безопасность:
- Same Origin Policy и CORS
- XSS (внедрение скриптов)
- CSRF (подделка запросов)
- mixed content (HTTP внутри HTTPS)
- утечки через неправильные заголовки безопасности (CSP и др.)
